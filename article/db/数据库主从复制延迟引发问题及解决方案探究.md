#### 问题描述：

业务中会出现刚刚写入一个数据库记录成功，但是另一个线程或者服务去数据库查询又查询不到该记录的情况，这种问题通常称为**读写分离的主从同步延迟带来的数据不一致问题**。

#### 解决方案：

主从同步延迟通常是必然现象，实际上是不可避免的，技术上没有灵丹妙药可以完全解决，最好是根据不同的业务场景，优化业务流程来解决。规避这个问题最关键的⼀点是，我们在设计系统的业务流程时，尽量不要在更新数据之后⽴即去查询更新后的数据。

下面来根据几个不同的业务场景来制定相应的解决方案。

- 场景1：电商订单

  拿订单系统来举例，我们⾃然的设计思路是，⽤⼾从购物⻋⾥发起结算创建订单，进⼊订单⻚，打开⽀付⻚⾯进⾏⽀付，⽀付完成后，按道理应该再返回⽀付之前的订单⻚。但如果这个时候⻢上⾃动返回订单⻚，就很可能会出现订单状态还是显⽰“未⽀付”。因为，⽀付完成后，订单库的主库中，订单状态已经被更新了，⽽订单⻚查询的从库中，这条订单记录的状态有可能还没更新。

  这种问题其实没什么好的技术⼿段来解决，所以你看⼤的电商，它⽀付完成后是不会⾃动跳回到订单⻚的，它增加了⼀个⽆关紧要的“⽀付完成”⻚⾯，其实这个⻚⾯没有任何有效的信息，就是告诉你⽀付成功，然后再放⼀些⼴告什么的。你如果想再看刚刚⽀付完成的订单，需要⼿动点⼀下，这样就很好地规避了主从同步延迟的问题。

- 场景2：论坛系统

  某论坛是主从数据库，我发一个帖子后立即刷新页面，因为显示帖子是读，这个时候如果延迟比较厉害，就会提示 404 -———帖子不存在，这就有问题了；我们还要假设用户的容忍度是看见自己的新内容，别人新的内容可以有延迟（实际上延迟是很小的时间单位）。

  针对此问题，可以使用以下方案：

  利用缓存；插入新的数据，会有last_id返回，组装成数据，缓存到前端。读取此 id 数据时，先从缓存取。

- 场景3：提现业务（没有实时性要求）

  我们的服务有用户提现业务，用户申请提现后，会立即给用户返回“提现成功”，然后通过消息队列的异步任务来访问微信的转账接口，给用户的微信账户转账。转账成功后，给用户的提现记录设置状态为提现成功。有时候由于主从延迟导致在异步任务中读取不到提现记录。

  因为此业务没有实时行要求，针对此问题，可以使用以下方案：

  提现的异步任务在消息队列中设置延迟执行时间，假设初次为3秒，用户申请提现3秒后，异步任务开始执行，先读取提现记录，如果读取不到的话，证明主从同步未完成，那么再发起延迟任务4秒后执行，4秒后执行的时候再次读取提现记录，如果还是读取不到，就那么再发起延迟任务5秒后执行，一共延迟执行3次。如果仍然读取不到提现记录的话，说明数据库主从同步出现了问题，可能要等好久之后才能同步成功。这个时候可以不执行该任务了，通过后续的定时任务来将这些提现流程批量执行完成。

- 场景4：银行转账业务（准确性高）

  针对银行转账这样的强事务型任务，没有太高的实时行要求，用户可以忍受等待几秒到十几秒，可以强制读取主库，这样就规避了主从延迟的问题。

- 场景5：实时性很高，准确性不高的业务

  采用三级缓存方案：写入数据的时候先写本地缓存，再写redis缓存，再写DB。读取数据的时候先读取本地缓存，本地缓存读取不到的话，读取redis缓存，redis读取不到的话，再读取DB，这样可以减轻DB的压力。

- 场景6：实时行较高，准确性比较高的业务

  优化版三级缓存方案：写入数据的时候先写本地缓存，再写redis缓存，再写DB，写入DB成功后再依次在本次缓存和redis缓存中写入字段“db_write_success”为1（**防止写入DB时系统崩溃，未写入DB成功**）。读取数据的时候先读取本地缓存，看db_write_success是否为1，为1的话执行后续流程。否则读取redis缓存，看db_write_success是否为1，为1的话执行后续流程。否则再读取DB从库，如果从库读取失败的话，就直接读取DB主库。

  这样既可以减轻DB的压力，又可以防止DB写入失败。

##### 参考

[**MySQL如何应对高并发（二）：读写分离**](https://g.yuque.com/u1552873/iwiwt3/wlk5uy)

[如何解决主从数据库同步延迟问题？](https://www.zhihu.com/question/20025096/answer/13715272)