#### 1、项目中使用redis的哪些方面？
答：
1、作为限流，可以对用户访问进行限流，防止用户刷接口，同时还对报警进行限流，防止相同的报警报警多次，可以使用滑动窗口算法，也可以使用令牌算法，令牌算法暂时没有使用，可以参考[python 基于redis的令牌桶限流](https://blog.csdn.net/u011519550/article/details/109246320)
2、分布式锁
3、数据库缓存
4、统计活跃用户，用zset
5、排行榜, zset, 这个待研究，不是自己写的
6、bitmap，统计测试管理平台的端口占用情况


#### 2、为啥Redis单线程模型也能效率这么高？
1）纯内存操作

Redis 将所有数据放在内存中，内存的响应时长大约为 100 纳秒，这是 redis 的 QPS 过万的重要基础。

2）核心是基于非阻塞的IO多路复用机制

有了非阻塞 IO 意味着线程在读写 IO 时可以不必再阻塞了，读写可以瞬间完成然后线程可以继续干别的事了。

redis 需要处理多个 IO 请求，同时把每个请求的结果返回给客户端。由于 redis 是单线程模型，同一时间只能处理一个 IO 事件，于是 redis 需要在合适的时间暂停对某个 IO 事件的处理，转而去处理另一个 IO 事件，这就需要用到IO多路复用技术了， 就好比一个管理者，能够管理个socket的IO事件，当选择了哪个socket，就处理哪个socket上的 IO 事件，其他 IO 事件就暂停处理了。

3）单线程反而避免了**多线程**的频繁**上下文切换**带来的性能问题。（百度多线程上下文切换）

第一，单线程可以简化数据结构和算法的实现。并发数据结构实现不但困难而且开发测试比较麻

第二，单线程避免了线程切换和竞态产生的消耗，对于服务端开发来说，**锁**和**线程切换**通常是性能杀手。

单线程的问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞，所以 redis 适用于那些需要**快速执行的场景**。

[Redis和多路复用模型](https://hogwartsrico.github.io/2020/06/24/Redis-and-Multiplexing/)

#### 3、redis rehash机制，rehash过程是启动一个进程还是怎么？会不会阻塞？

（Redis设计与实现P32页）

不会启动专门的进程或线程，也不会阻塞，使用的是渐进式rehash

以下是哈希表渐进式 rehash 的详细步骤：

1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。
2. 在字典中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ， 表示 rehash 工作正式开始。
3. 在 rehash 进行期间， **每次对字典执行添加、删除、查找或者更新操作时**， 程序除了执行指定的操作以外， 还会**顺带**将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。
4. 随着字典操作的不断执行， **最终在某个时间点上**， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。

渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。

**渐进式 rehash 执行期间的哈希表操作**:

因为在进行渐进式 rehash 的过程中， 字典会同时使用 `ht[0]` 和 `ht[1]` 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 `ht[0]` 里面进行查找， 如果没找到的话， 就会继续到 `ht[1]` 里面进行查找， 诸如此类。

另外， 在渐进式 rehash 执行期间， **新添加**到字典的键值对**一律会被保存到 `ht[1]`** 里面， 而 `ht[0]` 则不再进行任何添加操作： 这一措施保证了 `ht[0]` 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。

#### 4、redis字典的键和值分别存储什么类型的数据

字符串对象（注意有对象两个字）

哈希对象的编码可以是 `ziplist` 或者 `hashtable`

`hashtable` 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：

- 字典的每个键都是一个**字符串对象**， 对象中保存了键值对的键；
- 字典的每个值都是一个**字符串对象**， 对象中保存了键值对的值。

#### 5、redis做消息队列缺点

1. **不支持重复消费**：消费者拉取消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费，即不支持多个消费者消费同一批数据
2. **消息丢失**：消费者拉取到消息后，如果发生异常宕机，那这条消息就丢失了

[把Redis当作队列来用，真的合适吗？](https://mp.weixin.qq.com/s/RthQvzLHZRGNo-z6X_7jQQ)

#### 6、redis字符串底层原理

#### 7、redis AOF重写